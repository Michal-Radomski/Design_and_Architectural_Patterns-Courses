To use React Router effectively with React microfrontends (MFEs), the typical pattern is:

- Have a **main host React application** that uses React Router (e.g., `BrowserRouter`) to handle global routing between
  microfrontends.
- Each microfrontend is a separate React app that mounts inside the host app when its global route is active. Each
  microfrontend manages its **internal routing with React Router** using a basename corresponding to its route prefix.
- Use tools like **Webpack 5 Module Federation** to dynamically load MFEs into the host app.
- The host app defines top-level routes like `/app1/*`, `/app2/*` that load corresponding MFEs as React components with
  `React.Suspense`.
- Each MFE has its own `BrowserRouter` or `MemoryRouter` instance with a `basename` matching its route in the host app to
  handle inner navigation.
- For seamless cross-MFE navigation, the host app manages global links, and MFEs handle internal routing within their scope.
- To avoid conflicts, share React, ReactDOM, and React Router libraries versions between host and MFEs.

Example of host app routing setup:

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
const HostApp = () => (
  <BrowserRouter>
    <Routes>
      <Route path="/" element={<Home />} />
      <Route
        path="app1/*"
        element={
          <React.Suspense fallback="Loading">
            <MfeApp1 />
          </React.Suspense>
        }
      />
      <Route
        path="app2/*"
        element={
          <React.Suspense fallback="Loading">
            <MfeApp2 />
          </React.Suspense>
        }
      />
    </Routes>
  </BrowserRouter>
);
```

Each MFE example:

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
const MfeApp1 = () => (
  <BrowserRouter basename="/app1">
    <Routes>
      <Route path="/" element={<Dashboard />} />
      <Route path="settings" element={<Settings />} />
    </Routes>
  </BrowserRouter>
);
```

Using this approach:

- The host router controls which MFE is rendered.
- Each MFE uses `basename` to scope internal routing under its host path.
- Shared dependencies and Module Federation avoid wrapping React and React Router multiple times.
- Navigation inside an MFE updates the URL only within the MFE's `basename` route.
- Navigating between MFEs involves the host router switching rendered MFEs.

This pattern is recommended and discussed in multiple React microfrontend resources and examples, including advice from
GitHub and community posts about sharing the same React Router version and using `basename` props for scoping
routes.[1][2][3][5][6]

For added flexibility and mixing frameworks, some teams use Single SPA alongside React Router.[2]

In summary, **manage global routing in the host app, pass route segments to microfrontends via React Routerâ€™s basename, and
use Webpack Module Federation to load MFEs, keeping React Router instances isolated but coordinated across apps**.

This allows smooth routing within and between microfrontends built with React.

[1] https://www.reddit.com/r/reactjs/comments/1hbv6a0/microfrontends_mfes_using_react_and_webpack/ [2]
https://www.reddit.com/r/reactjs/comments/1ccqj0j/need_help_in_implementing_routing_on_react_micro/ [3]
https://maybe.works/blogs/react-micro-frontend [4] https://blog.logrocket.com/build-micro-frontend-application-react/ [5]
https://stackoverflow.com/questions/72768822/micro-frontend-by-module-federation-with-react-router-dom-v6 [6]
https://www.youtube.com/watch?v=v87SEnyrC14 [7]
https://dev.to/infoxicator/why-react-router-is-excellent-for-micro-frontends-2a21 [8]
https://www.youtube.com/watch?v=tI8RYB5rcVw [9]
https://docs.sentry.io/platforms/javascript/guides/react-router/best-practices/micro-frontends/ [10]
https://www.youtube.com/watch?v=uRKUxZQ74os
