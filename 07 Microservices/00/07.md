The TypeScript error "Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.ts(7017)"
occurs when you try to access or add properties on the globalThis object using dynamic keys, but the TypeScript compiler does
not know the types of those properties because globalThis lacks an index signature.

To fix this error, you need to explicitly declare the types for the global properties you are accessing or extending in a
TypeScript declaration file (e.g., `global.d.ts`). This informs TypeScript about the shape of the global object.

Typical steps to resolve this:

1. Create or update a `global.d.ts` file in your project with content like this:

```ts
declare global {
  var yourGlobalVar: YourType;
  function yourGlobalFunction(): ReturnType;
}
```

2. For example, if you want to add a global property `myGlobalProp` of type `string`, you can declare:

```ts
declare global {
  var myGlobalProp: string;
}
```

3. If you want to add properties dynamically by index, you need to declare an index signature in the global interface
   explicitly, but generally globalThis does not have one by default.

4. Make sure this declaration file is included in your `tsconfig.json` under `include` or `files`.

One common usage is to declare in `global.d.ts`:

```ts
export {};

declare global {
  var EventManager: EventManagerType.EventManager;
}
```

And then in your code you can safely use `globalThis.EventManager` without errors.

This approach gives TypeScript the necessary type information for the properties on `globalThis`, avoiding the error about
missing index signature and implicit `any` type.

In summary, the error means you are accessing or assigning to a `globalThis` property that TypeScript does not know about.
You must declare those properties in a global augmentation file so TS understands their types.

This explanation and example fixes are detailed and discussed in multiple TypeScript community posts specifically about
adding globals to `globalThis` and dealing with this exact error.[1][2][4][5]

[1](https://www.gauthmath.com/solution/lukaEm9ZrGn/What-does-the-TypeScript-error-element-implicitly-has-an-any-type-because-type-t)
[2](https://stackoverflow.com/questions/68481686/type-typeof-globalthis-has-no-index-signature)
[3](https://www.reddit.com/r/code/comments/1eh489w/help_with_typescript/)
[4](https://questions.deno.com/m/1314947652852383835) [5](https://github.com/nextauthjs/next-auth/issues/8358)
[6](https://github.com/nextauthjs/next-auth/discussions/3320)
[7](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis)
[8](https://lightrun.com/answers/nextauthjs-next-auth-property-prisma-doesnt-exist-on-global--typeof-globalthis)
[9](https://forum.makecode.com/t/typescript-error-element-implicitly-has-an-any-type-because-type-object-has-no-index-signature/16019)

The reason for using `var` in `declare global` or when augmenting `globalThis` in TypeScript is tied to how variables become
properties of the global object at runtime.

- Variables declared with `var` at the global scope automatically become properties of the global object (`globalThis` in
  modern environments). This means `var` declarations are reflected as properties on `globalThis`.

- However, variables declared with `let` or `const` at the global scope do _not_ become properties of the global object. They
  are scoped globally, but do not create or add properties on `globalThis`.

In TypeScript, when you augment `globalThis` (e.g., in `declare global`), if you want those declarations to _exist as
properties_ on `globalThis` at runtime, you use `var`. This matches the behavior of JavaScript engines.

Example:

```ts
declare global {
  var myGlobalVar: string;
  let myGlobalLet: number;
}
```

- `myGlobalVar` will be accessible as `globalThis.myGlobalVar`
- `myGlobalLet` will not become a property of `globalThis` even though it's globally scoped.

This difference leads to why you often see `var` used in TypeScript global declarations when you want to add properties to
the global object to avoid type errors like "property does not exist on typeof globalThis".

In summary:

- Use `var` in global declarations to add actual properties to `globalThis` runtime object.
- `let` and `const` are block-scoped and do not add properties to `globalThis` even if declared globally.
- This behavior is consistent with JavaScript semantics and TypeScript models that accurately.

This explanation aligns with JavaScript scoping rules and TypeScript's handling of global scope augmentation.[1][2][3][4]

[1](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)
[2](https://www.javascripttutorial.net/difference-between-var-and-let/)
[3](https://github.com/microsoft/TypeScript/issues/56442)
[4](https://stackoverflow.com/questions/59459312/using-globalthis-in-typescript)
[5](https://www.reddit.com/r/learnjavascript/comments/mrbt1q/let_vs_var_global_scope_vs_local_scope/)
[6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis)
[7](https://github.com/typescript-eslint/typescript-eslint/issues/3617)
